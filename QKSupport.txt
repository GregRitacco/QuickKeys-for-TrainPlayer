** Quick Keys support utilities currently in use
Let version = 20220105

Proc DefineCarrageReturn

** Simulate ReadLine for text strings
Let xCR = "
"

EndProc
***************************************************************************


Proc SetLanguage

** Read in text for help page
Let HelpLoc = $DataDir + "\Subroutines\QuickKeys\Support\" + %1 + "Help.txt"
Let HelpFile = $File(@HelpLoc, Open)
let HelpSet = $file(@HelpFile, ReadAll)
Call $File(@HelpLoc, Close)

** Read in text for o2o reports
Let o2oLoc = $DataDir + "\Subroutines\QuickKeys\Support\" + %1 + "o2o.txt"
Let o2oFile = $File(@o2oLoc, Open)
Let o2oSet = $File(@o2oFile, ReadAll)
Call $File(@o2oLoc, Close)


** Read in text for Quick Keys pop up messages
Let MessageLoc = $DataDir + "\Subroutines\QuickKeys\Support\" + %1 + "Message.txt"
Let MessageFile = $File(@MessageLoc, Open)
let MessageSet = $file(@MessageFile, ReadAll)
Call $File(@MessageLoc, Close)

** Read in text for Quick Keys utility menu
Let UtilityLoc = $DataDir + "\Subroutines\QuickKeys\Support\" + %1 + "Utility.txt"
Let UtilityFile = $File(@UtilityLoc, Open)
let UtilitySet = $file(@UtilityFile, ReadAll)
Call $File(@UtilityLoc, Close)

EndProc
***************************************************************************


Proc HelpUtilList ** Pass in xMatrix

Let xHelpAll = ""
Let xUtilAll = ""
Let i = 0
While (i < $Set(%1, Count))
  If ($Set(%1, Get, @i) = 1)
    Let xHelpAll = @xHelpAll $Set(@HelpSet, Get, @i)
    Let xUtilAll = @xUtilAll + $Set(@UtilitySet, Get, @i)
  EndIf
  Let i = @i + 1
EndWhile
Let xUtilAll = @xUtilAll + \n\n$Set(@UtilitySet, Get, 9) \n

EndProc
***************************************************************************

Proc NoteWindow ** Open or close the help window

If (%2 = 1) ** force window open
  Note %1
Else
  Note %1
EndIf

EndProc
***************************************************************************


Proc ProcessorInfo

** Adjustment for processor speed
** Call $System("wmic path win32_processor get CurrentClockSpeed, DeviceID, MaxClockSpeed, Name, NumberOfCores /format:LIST |more > %homepath%\AppData\Roaming\TrainPlayer\Reports\ProcessorInfo.txt")

Call $System("%homepath%\AppData\Roaming\TrainPlayer\Subroutines\QuickKeys\ProcessorInfo.bat") ** This is the WMIC command

Let xCSLoc = $DataDir + "\Reports\QK - ProcessorInfo.txt"
If($File(@xCSLoc, Exists) = 1)
  Let xCSFile = $File(@xCSLoc, Open)
  While(1 = 1)
    Let xLine = $File(@xCSFile, ReadLine)
    If ($String(@xLine, StartsWith, "MaxClockSpeed") = 1)
      Call $String(@xLine, NextToken, "=")
      Let xPS = @xLine ** xPS is the processor speed
    EndIf
    If ($String(@xLine, StartsWith, "DeviceID") = 1)
      Call $String(@xLine, NextToken, "=")
      Let xCPU = @xCPU + 1 ** xCPU is the number of processors
    EndIf
    If (@xLine = "EOF")
      Call $File(@xCSFile, Close)
      Break
    EndIf
  EndWhile
Else
  Let xPS = 2500
  Let xCPU = 1
  Echo ProcessorInfo.txt is missing
EndIf
Let xCurve = 0,1.0,1.5,1.75,2.0,2.25,2.5,2.75,3.0, ** Power of computer as processors are added
Let xCS = @xPS * $Set(@xCurve, Get, @xCPU)
EndProc
****************************************************************************


Proc ReportTpInventory

  Echo o2o Utility - Report of TrainPlayer rolling stock inventory

  Echo Working on it......

  Let jID = $Ops(find, Cars.Car, All, Car)
  Let jCount = $Set(@jID, Count)

  Let jInventory = $DATE + "-" + $TIME
  Let jKey = "TP Car; TP Type; TP AAR; JMRI Location; JMRI Track; TP Load; TP Kernel; Car ID"
  Let jInventory = @jInventory + \n@jKey

  Let i = 1
  While (i <= @jCount)

    Let jCar = $Ops(Get, Cars.Car, @i)
    Let jKernel = $Car(@jCar, kernel)

    Let jTrack = $Ops(Get, Cars.Location, @i)
    Let jLocale = $Ops(Find, Locs.Track, @jTrack)
    Let jLocale = $Ops(Get, Locs.Locale, @jLocale)
    If(@jTrack = "~")
      Let jLocale = "Unknown;~"
    EndIf
    If(@jTrack = "")
      Let jLocale = "Unknown;~"
    EndIf

    Let jInventory = @jInventory +\n@jCar + ";" + $Ops(Get, Cars.Type, @i) + ";" + $Ops(Get, Cars.AAR, @i) + ";" +  @jLocale + ";" + $Ops(Get, Cars.Load, @i) + ";" + @jKernel + ";" + $Car(@jCar, Car_ID)
    Let i = @i + 1

  EndWhile

  Let jInventoryLoc = $DataDir + "\Reports\TrainPlayer Report - Rolling Stock.txt"
  Call $Write(@jInventoryLoc, @jInventory)

  Echo Rolling stock count: @jCount

EndProc
****************************************************************************


Proc ReportTpLocations

  Echo o2o Utility - Report of all TrainPlayer locations

  Let jID = $Ops(find, Locs.Class, All, ID)
  Let jCount = $Set(@jID, Count)

  Let jLocation = $DATE + "-" + $TIME
  Let jLocation = @jLocation +\n$Layout
  Let jLocation = @jLocation +\n$Layout(Description)
  Let jLocation = @jLocation +\n + "TP ID;JMRI Location;JMRI Track;TP Track;TP Class;TP Spaces"

  Let i = 1
  While (i <= @jCount)

    Let thisTrack = $Ops(Get, Locs.Track, @i)

    If($Ops(Get, Locs.Class, @i) = "industry")
      Let cap = $Ops(Get, Locs.VacantSpots, @i)
    Else
      Let cap = $Capac(@thisTrack, all)
    EndIf

    Let jLocation = @jLocation + \n$Ops(Get, Locations.ID, @i) + ";" + $Ops(Get, Locs.Locale, @i) + ";" + @thisTrack + ";" + $Ops(Get, Locs.Class, @i) + ";" + @cap
    Let i = @i + 1

  EndWhile


  Let jLocationLoc = $DataDir + "\Reports\TrainPlayer Report - Locations.txt"
  Call $Write(@jLocationLoc, @jLocation)

  Echo Location count: @jCount

EndProc
****************************************************************************


Proc ReportTpIndustries

  Echo o2o Utility - Report of all TrainPlayer industries

  Let jID = $Ops(find, Industries.Locale, All, ID)
  Let jCount = $Set(@jID, Count)

  Let jIndustry = $DATE + "-" + $TIME
  Let jIndustry = @jIndustry + \n"TP ID;JMRI Location;JMRI Track;TP Industry;TP AAR;TP S/R;Load;TP Staging;TP ViaIn;TP Via Out"

  Let i = 1
  While (i <= @jCount)

    Let jIndustry = @jIndustry + \n$Ops(Get, ind.ID, @i) + ";" + $Ops(Get, ind.Locale, @i) + ";" + $Ops(Get, ind.Industry, @i) + ";" + $Ops(Get, ind.AAR, @i) + ";" + $Ops(Get, ind.S/R, @i) + ";" + $Ops(Get, ind.Load, @i) + ";" + $Ops(Get, ind.Staging, @i) + ";" + $Ops(Get, ind.ViaIn, @i) + ";" + $Ops(Get, ind.ViaOut, @i)
    Let i = @i + 1

  EndWhile


  Let jIndustryyLoc = $DataDir + "\Reports\TrainPlayer Report - Industries.txt"
  Call $Write(@jIndustryyLoc, @jIndustry)

  Echo Industry count: @jCount

EndProc
****************************************************************************

Proc AddKernels

  Echo o2o Utility - Group equipment together into a JMRI like consist or kernel

  Let jKernelSet = $Train($Train, CarLabels)
  Input jK What is the kernel name?
  While($Set(@jKernelSet, Count) <> 0)
    Let jCar = $String(@jKernelSet,  NextToken)
    Let $Car(@jCar, kernel) = @jK
    Echo @jK @jCar
  EndWhile

EndProc
****************************************************************************


Proc InitCars

  Echo o2o Utility - set all or train rolling stock destinations

  If(%1 = "")
    Let jXmessage = $Set(@o2oSet, Get, 34)
    Let jX = $Msgbox("YN", @jXmessage)
    If (@jX = 1)
      Let jLabels = $Layout(IDSet, CarLabels) ** all trains on layout
    Else
      Let jLabels = $Train($Train, CarIDs) ** selected train
    EndIf
  Else
    Let jLabels = %1 ** passed in train label set
    Let jX = 0
  EndIf

  While($Set(@jLabels, Count) <> 0)
    Let jTemp = $String(@jLabels, NextToken) ** car label
    Let jCarLoc = $Car(@jTemp, Track) ** track ID
    Let jCarLoc = $Track(@jCarLoc, Label) ** track label
    Let $Car(@jTemp, Dest) = @jCarLoc
    If (@jCarLoc = "") ** track is unlabeled
      Let $Car(@jTemp, Dest) = "~"
      Continue
    EndIf
    If ($Car(@jTemp, LoadName) = "") ** car is unloadable
      Let $Car(@jTemp, Dest) = "~"
      Continue
    EndIf

  EndWhile
  View Refresh
  Echo InitCars Complete

EndProc
****************************************************************************


Proc InitTracks

Echo o2o Utility - Set all <> or ~ tracks to null
Let jIDs = $Layout(IDSet, TrackIDs)
Let i = 0
While(@i < $Set(@jIDs, Count))
  Let jTrackID = $Set(@jIDs, Get, @i)
  If($TRACK(@jTrackID, Label) = "")
    Let $TRACK(@jTrackID, Label) = "~"
  EndIf
  If($TRACK(@jTrackID, Label) = "<>")
    Let $TRACK(@jTrackID, Label) = ""
  EndIf
  Let i = @i + 1
EndWhile
Echo InitTracks Complete

EndProc
****************************************************************************


Proc AutoLabel

  ** Attach to loco to automatically label tracks

  Middle:
  After 00:00:01
  If($Speed = 0)
   Input xLabel "Enter the Track Label"
   Speed 1
  Endif
  Let xTrack = $Car($Car, Track)
  Let $Track(@xTrack, Label) = @xLabel
  View Refresh
  GoTo Middle

EndProc
****************************************************************************
